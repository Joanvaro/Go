package main

import(
    "bytes"
    "fmt"
    "reflect"
    cbugorji "github.com/ugorji/go/codec"
)

type Event struct {
    Time    uint64
    State   uint64
    Items   []DataLogger
}

type DataLogger struct {
    Id      uint64
    Time    uint64
    Value   []int64
    Coord   [][]uint64
}

func decodeCbor(in []byte) (interface{}, error) { 
    var returnedValue interface{}
    bufferCBOR := bytes.NewBuffer(in)
    err := cbugorji.NewDecoderBytes(bufferCBOR.Bytes(), new(cbugorji.CborHandle)).Decode(&returnedValue)
    return returnedValue, err
}

func parsingHeader(header interface{}) (Event){

    initialValues := header.([]interface{})

    rawEvent := Event {
        State:      initialValues[0].(uint64), 
        Time:       initialValues[2].(uint64),
    }

    for idx, id := range initialValues[1].([]interface{}) {
        item := DataLogger {
            Time:   initialValues[2].(uint64),
            Id:     id.(uint64),
        }
        
        if item.Id == 2048 {
            GpsData := []uint64{}
            
            for _, val := range initialValues[3+idx].([]interface{}) {
                GpsData = append(GpsData, val.(uint64))
            }

            item.Coord = append(item.Coord, GpsData)
        } else {
            item.Value = append(item.Value, initialValues[3+idx].(int64))
        }

        rawEvent.Items = append(rawEvent.Items, item)
    }
    return rawEvent
}

func parsingDiff(diff []interface{}, events Event) {

    for _, sample := range diff {
        fmt.Println(sample)
        sample := sample.([]interface{})
        index := sample[1].(uint64)

        if events.Items[index].Id == 2048 {
            GpsData := []uint64{}

            lastValue := events.Items[index].Coord[len(events.Items[index].Coord) - 1]
            for idx, val := range sample[2].([]interface{}) {
                GpsData = append(GpsData, lastValue[idx] + val.(uint64))
            }
            events.Items[index].Coord = append(events.Items[index].Coord, GpsData)
        } else {

            lastValue := events.Items[index].Value[len(events.Items[index].Value) - 1]
            fmt.Println(lastValue)
            fmt.Println(reflect.TypeOf(sample[2]))
            newValue := lastValue + sample[2].(int64)
            fmt.Println("Hello")
            events.Items[index].Value = append(events.Items[index].Value, newValue)
        }
    }

    fmt.Println(events)

}

func parsingStream(stream interface{}) {

    for _, rcrd := range stream.([]interface{}) {
        var record []interface{}
        record = rcrd.([]interface{})

        header, diff := record[0], record[1:]
        fmt.Println("header = ", header)
        fmt.Println("diff = ", diff)

        streamEvents := parsingHeader(header) 
        parsingDiff(diff, streamEvents)
        //fmt.Println(streamEvents)
    }
}

func main() {
    
    cbor := []byte{ 
        0x81, 0x97, 0x86, 0x03, 0x83, 0x19, 0x08, 0x00, 0x19, 0x01, 0x20, 0x19, 0x06, 0x40, 0x1A, 0x62, 0xD8, 0xF0, 0x0B,
        0x82, 0x19, 0xCB, 0x8C, 0x19, 0xC8, 0xB0, 0x18, 0x82, 0x0C, 0x83, 0x01, 0x00, 0x82, 0x0A, 0x18, 0x64, 0x83,
        0x01, 0x01, 0x24, 0x83, 0x01, 0x00, 0x82, 0x39, 0x01, 0x17, 0x19, 0x02, 0x39, 0x83, 0x01, 0x01, 0x02, 0x83,
        0x01, 0x00, 0x82, 0x04, 0x29, 0x83, 0x01, 0x01, 0x0A, 0x83, 0x01, 0x00, 0x82, 0x00, 0x00, 0x83, 0x01, 0x01,
        0x33, 0x83, 0x01, 0x00, 0x82, 0x39, 0x07, 0x73, 0x39, 0x06, 0x20, 0x83, 0x01, 0x01, 0x04, 0x83, 0x01, 0x02,
        0x20, 0x83, 0x01, 0x00, 0x82, 0x0A, 0x18, 0x64, 0x83, 0x01, 0x01, 0x24, 0x83, 0x01, 0x00, 0x82, 0x39, 0x01,
        0x17, 0x19, 0x02, 0x39, 0x83, 0x01, 0x01, 0x02, 0x83, 0x01, 0x00, 0x82, 0x04, 0x29, 0x83, 0x01, 0x01, 0x0A,
        0x83, 0x01, 0x00, 0x82, 0x00, 0x00, 0x83, 0x01, 0x01, 0x33, 0x83, 0x01, 0x00, 0x82, 0x39, 0x07, 0x73, 0x39,
        0x06, 0x20, 0x83, 0x01, 0x01, 0x04, 0x83, 0x01, 0x02, 0x20,
    }

    /*cbor := []byte{
        0x82, 0x8C, 0x86, 0x03, 0x83, 0x19, 0x08, 0x00, 0x19, 0x01, 0x20, 0x19, 0x06, 0x40, 0x1A, 0x62, 0xD8, 0xF0,
        0x0B, 0x82, 0x19, 0xCB, 0x8C, 0x19, 0xC8, 0xB0, 0x18, 0x82, 0x0C, 0x83, 0x01, 0x00, 0x82, 0x0A, 0x18, 0x64,
        0x83, 0x01, 0x01, 0x24, 0x83, 0x01, 0x00, 0x82, 0x39, 0x01, 0x17, 0x19, 0x02, 0x39, 0x83, 0x01, 0x01, 0x02,
        0x83, 0x01, 0x00, 0x82, 0x04, 0x29, 0x83, 0x01, 0x01, 0x0A, 0x83, 0x01, 0x00, 0x82, 0x00, 0x00, 0x83, 0x01,
        0x01, 0x33, 0x83, 0x01, 0x00, 0x82, 0x39, 0x07, 0x73, 0x39, 0x06, 0x20, 0x83, 0x01, 0x01, 0x04, 0x83, 0x01, 
        0x02, 0x20, 0x87, 0x85, 0x04, 0x82, 0x19, 0x08, 0x00, 0x19, 0x06, 0x40, 0x1A, 0x62, 0xD8, 0xF0, 0x10, 0x82,
        0x19, 0xCB, 0x8C, 0x19, 0xC8, 0xB0, 0x0C, 0x83, 0x01, 0x00, 0x82, 0x0A, 0x18, 0x64, 0x83, 0x01, 0x00, 0x82,
        0x39, 0x01, 0x17, 0x19, 0x02, 0x39, 0x83, 0x01, 0x00, 0x82, 0x04, 0x29, 0x83, 0x01, 0x00, 0x82, 0x00, 0x00,
        0x83, 0x01, 0x00, 0x82, 0x39, 0x07, 0x73, 0x39, 0x06, 0x20, 0x83, 0x01, 0x01, 0x20,
    }*/
    
    decodedCbor, err := decodeCbor(cbor)

    if err != nil {
        fmt.Println(err)
    }

    //fmt.Println(decodedCbor)

    parsingStream(decodedCbor)

}
