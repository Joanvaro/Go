package main

import(
    "bytes"
    "fmt"
    //"reflect"
    cbugorji "github.com/ugorji/go/codec"
)

type Event struct {
    Time    uint64
    State   uint64
    Items   []DataLogger
}

type DataLogger struct {
    Id      uint64
    Time    uint64
    Value   []uint64
    Coord   [][]uint64
}

func decodeCbor(in []byte) (interface{}, error) { 
    var returnedValue interface{}
    bufferCBOR := bytes.NewBuffer(in)
    err := cbugorji.NewDecoderBytes(bufferCBOR.Bytes(), new(cbugorji.CborHandle)).Decode(&returnedValue)
    return returnedValue, err
}

func parsingHeader(header interface{}) (Event){

    initialValues := header.([]interface{})

    rawEvent := Event {
        State:      initialValues[0].(uint64), 
        Time:       initialValues[2].(uint64),
    }

    for idx, id := range initialValues[1].([]interface{}) {
        item := DataLogger {
            Time:   initialValues[2].(uint64),
            Id:     id.(uint64),
        }
        
        if id == 2048 {
            GpsData := []uint64{}
            
            for _, val := range initialValues[3+idx].([]interface{}) {
                GpsData = append(GpsData, val.(uint64))
            }

            item.Coord = append(item.Coord, GpsData)
        } else {
            item.Value = append(item.Value, initialValues[3+idx].(uint64))
        }

        rawEvent.Items = append(rawEvent.Items, item)
    }
    return rawEvent
}

/*func parsingDiff(diff []interface{}, events Event) {

    for _, sample := range diff {

        sample := sample.([]interface{})
        index := sample[1].(uint64)

        fmt.Println(reflect.TypeOf(sample[2]))
        events.Items[len(events.Items)-1].Values[index] = append(events.Items[len(events.Items)-1].Values[index], sample[2].(interface{}))
        

    }

    fmt.Println(events)

}*/

func parsingStream(stream interface{}) {

    for _, rcrd := range stream.([]interface{}) {
        //fmt.Println(rcrd)
        //fmt.Printf("\n")
        var record []interface{}
        record = rcrd.([]interface{})

        header, diff := record[0], record[1:]
        fmt.Println("header = ", header)
        fmt.Println("diff = ", diff)

        streamEvents := parsingHeader(header) 
        //parsingDiff(diff, streamEvents)
        fmt.Println(streamEvents)
    }
}

func main() {
    
    cbor := []byte{ 
        0x81, 0x97, 0x86, 0x03, 0x83, 0x19, 0x08, 0x00, 0x19, 0x01, 0x20, 0x19, 0x06, 0x40, 0x1A, 0x62, 0xD8, 0xF0, 0x0B,
        0x82, 0x19, 0xCB, 0x8C, 0x19, 0xC8, 0xB0, 0x18, 0x82, 0x0C, 0x83, 0x01, 0x00, 0x82, 0x0A, 0x18, 0x64, 0x83,
        0x01, 0x01, 0x24, 0x83, 0x01, 0x00, 0x82, 0x39, 0x01, 0x17, 0x19, 0x02, 0x39, 0x83, 0x01, 0x01, 0x02, 0x83,
        0x01, 0x00, 0x82, 0x04, 0x29, 0x83, 0x01, 0x01, 0x0A, 0x83, 0x01, 0x00, 0x82, 0x00, 0x00, 0x83, 0x01, 0x01,
        0x33, 0x83, 0x01, 0x00, 0x82, 0x39, 0x07, 0x73, 0x39, 0x06, 0x20, 0x83, 0x01, 0x01, 0x04, 0x83, 0x01, 0x02,
        0x20, 0x83, 0x01, 0x00, 0x82, 0x0A, 0x18, 0x64, 0x83, 0x01, 0x01, 0x24, 0x83, 0x01, 0x00, 0x82, 0x39, 0x01,
        0x17, 0x19, 0x02, 0x39, 0x83, 0x01, 0x01, 0x02, 0x83, 0x01, 0x00, 0x82, 0x04, 0x29, 0x83, 0x01, 0x01, 0x0A,
        0x83, 0x01, 0x00, 0x82, 0x00, 0x00, 0x83, 0x01, 0x01, 0x33, 0x83, 0x01, 0x00, 0x82, 0x39, 0x07, 0x73, 0x39,
        0x06, 0x20, 0x83, 0x01, 0x01, 0x04, 0x83, 0x01, 0x02, 0x20,
    }

    /*cbor := []byte{
        0x82, 0x8C, 0x86, 0x03, 0x83, 0x19, 0x08, 0x00, 0x19, 0x01, 0x20, 0x19, 0x06, 0x40, 0x1A, 0x62, 0xD8, 0xF0,
        0x0B, 0x82, 0x19, 0xCB, 0x8C, 0x19, 0xC8, 0xB0, 0x18, 0x82, 0x0C, 0x83, 0x01, 0x00, 0x82, 0x0A, 0x18, 0x64,
        0x83, 0x01, 0x01, 0x24, 0x83, 0x01, 0x00, 0x82, 0x39, 0x01, 0x17, 0x19, 0x02, 0x39, 0x83, 0x01, 0x01, 0x02,
        0x83, 0x01, 0x00, 0x82, 0x04, 0x29, 0x83, 0x01, 0x01, 0x0A, 0x83, 0x01, 0x00, 0x82, 0x00, 0x00, 0x83, 0x01,
        0x01, 0x33, 0x83, 0x01, 0x00, 0x82, 0x39, 0x07, 0x73, 0x39, 0x06, 0x20, 0x83, 0x01, 0x01, 0x04, 0x83, 0x01, 
        0x02, 0x20, 0x87, 0x85, 0x04, 0x82, 0x19, 0x08, 0x00, 0x19, 0x06, 0x40, 0x1A, 0x62, 0xD8, 0xF0, 0x10, 0x82,
        0x19, 0xCB, 0x8C, 0x19, 0xC8, 0xB0, 0x0C, 0x83, 0x01, 0x00, 0x82, 0x0A, 0x18, 0x64, 0x83, 0x01, 0x00, 0x82,
        0x39, 0x01, 0x17, 0x19, 0x02, 0x39, 0x83, 0x01, 0x00, 0x82, 0x04, 0x29, 0x83, 0x01, 0x00, 0x82, 0x00, 0x00,
        0x83, 0x01, 0x00, 0x82, 0x39, 0x07, 0x73, 0x39, 0x06, 0x20, 0x83, 0x01, 0x01, 0x20,
    }*/
    
    decodedCbor, err := decodeCbor(cbor)

    if err != nil {
        fmt.Println(err)
    }

    //fmt.Println(decodedCbor)

    parsingStream(decodedCbor)

}
